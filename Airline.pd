//*******************************************************
//* File:    /Airline.pd
//* Author:  UP696771
//* License: See /License.txt
//* Assumptions: See /Assumptions.txt
//*******************************************************

class Airline ^=
abstract
	var
		pilots : set of Pilot,
		flights : map of (string -> Flight),
		aircraft : set of Aircraft;
		
	invariant
		#aircraft > 0, // ASSUMPTION: Airlines need at least one aircraft to operate
		#pilots > 0, // ASSUMPTION: Airlines need at least one pilot to operate
		forall p::pilots :- exists a::aircraft :- a in p.flyables, // ASSUMPTION: A pilot cannot work for an airline without being able to fly at least one of its plane types
		forall f::flights.ran :- f.aircraft in aircraft
//		forall p::pilots :- (
//			let pflights ^= those f::flights.ranb :- f.pilot = p;
//			let dates ^= for f::pflights yield f.date;
//			forall date::dates :- date#dates <= 2
//		)
		
confined
	function pilotsFlightsAsBag(pilot:Pilot):bag of Flight
		^= those f::flights.ranb :- f.pilot = pilot;
interface

	schema! addFlight(flight:Flight)
		pre
			flight.code ~in flights.dom,
			flight.aircraft in aircraft,
			(
				[flight.pilot ~= null]: (
					let pilot ^= (flight.pilot is Pilot);
					pilot in pilots &
					flight.aircraft in pilot.flyables
				),
					//& (
						//let pflights ^= pilotsFlightsAsBag(pilot).append(flight);
						//let dates ^= for f::pflights yield f.date;
						//forall date::dates :- date#dates <= 2
					//)
				//),
				[]: true
			)
		post flights! = flights.append(flight.code -> flight)
		assert 
			flight.code in flights'.dom,
			flight in flights'.ran;
			
	schema! removeFlight(code:string)
		pre
			code in flights.dom,
			(	let flight ^= flights[code];
				[flight.pilot ~= null]: (
					let pilot ^= (flight.pilot is Pilot);
					pilot in pilots &
					flight.aircraft in pilot.flyables
				),
				[]: true
			)
		post flights! = flights.remove(code)
		assert
			code ~in flights'.dom;

	schema! addPassenger(fcode:string, passenger:Passenger)
		pre 
			fcode in flights.dom,
			~flights[fcode].isFull
		post flights[fcode]!addPassenger(passenger)
		assert 
			fcode in flights'.dom,
			passenger in flights'[fcode].passengers;

	schema! assignPilotToFlight(fcode:string, pilot:Pilot)
		pre
			pilot in pilots,
			fcode in flights.dom,
			flights[fcode].aircraft in pilot.flyables,
			(
				let flight ^= flights[fcode];
				let pflights ^= pilotsFlights(pilot).append(flight);
				//flight.aircraft in pilot.flyables,
				(those x::pflights :- #(those y::pflights :- x=y | x.date = y.date) <= 2) = pflights
			)
		post flights[fcode]!setPilot(pilot);

	schema! removePilotFromFlight(fcode:string)
		pre fcode in flights.dom
		post flights[fcode]!setPilot(null)
		assert 
			fcode in flights'.dom,
			flights'[fcode].pilot = null;

	function pilotsFlights(pilot:Pilot): set of Flight
		^= those f::flights.ran :- f.pilot = pilot;

	function fullFlights:set of Flight
		^= those f::flights.ran :- f.isFull;
		
	function flightsToAirport(airport:Airport): set of Flight
		^= those f::flights.ran :- f.route.y = airport;

	function flightsFromAirport(airport:Airport): set of Flight
		^= those f::flights.ran :- f.route.x = airport;
		
	build{!pilots:set of Pilot, !aircraft:set of Aircraft}
		pre
			#aircraft > 0,
			#pilots > 0,
			forall p::pilots :- exists a::aircraft :- a in p.flyables
		post flights! = map of (string -> Flight){};
end;